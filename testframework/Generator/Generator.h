#ifndef GENERATOR_H
#define GENERATOR_H

#include <cctype>

template <typename T>
class Generator
{
private:
protected:
	T _cvalue;
public:
	Generator<T>();
	virtual ~Generator<T>();

	/**
	 * Check if a generator have reached the end of its generations
	 * options
	 *
	 * @return		true if the generator have reached its end, false
	 * 				else
	 */
	virtual bool finished() const = 0;

	/**
	 * Generate a new value according to the generator parameters
	 *
	 * @return		the newly generated value
	 */
	virtual T generate() = 0;

	/**
	 * @brief Return the nth element of the generator, the generator will
	 * be reset after this call
	 * 
	 * @param n index of the element
	 * 
	 * @return 
	 */
	virtual T get_nth(std::size_t n);

	/**
	 * The maximum number of generation of this generator
	 *
	 * @return		the number of value a generator can send
	 * 				before being reset
	 */
	virtual std::size_t size() const = 0;

	/**
	 * The current number of value generated by this generator,
	 * on reset the counter is set to 0
	 *
	 * @return		the current number of values generated by this generator
	 */
	virtual std::size_t current() const = 0;

	/**
	 * Reset this generator allowing it to be rerun,
	 * it will be automatically called if generate if called when the generator
	 * is allready finished
	 */
	virtual void reset() = 0;

	/**
	 * @brief Return the last value generated by the generator
	 * 
	 * @return The last value generated by the generator
	 */
	T value() const;
};

template <typename T>
Generator<T>::Generator() {}

template <typename T>
Generator<T>::~Generator() {}

template <typename T>
T Generator<T>::value() const
{
	return (this->_cvalue);
}

template <typename T>
T Generator<T>::get_nth(std::size_t n)
{
	std::size_t i;
	T retv;

	i = 0;
	while (i++ < n)
		this->generate();
	retv = this->current();
	this->reset();
	return (retv);
}
#endif

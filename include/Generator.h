#ifndef GENERATOR_H
# define GENERATOR_H

# include <cctype>

template <typename T>
class Generator
{
	private:
	public:
		Generator<T>();
		~Generator<T>();

		/**
		 * Check if a generator have reached the end of its generations
		 * options
		 *
		 * @return		true if the generator have reached its end, false
		 * 				else
		 */
		virtual	bool		finished() const = 0;

		/**
		 * Generate a new value according to the generator parameters
		 *
		 * @return		the newly generated value
		 */
		virtual T			generate() = 0;

		/**
		 * The maximum number of generation of this generator
		 *
		 * @return		the number of value a generator can send 
		 * 				before being reset
		 */
		virtual std::size_t	size() const = 0;

		/**
		 * The current number of value generated by this generator,
		 * on reset the counter is set to 0
		 *
		 * @return		the current number of values generated by this generator
		 */
		virtual	std::size_t	current() const = 0;

		/**
		 * Reset this generator allowing it to be rerun,
		 * it will be automatically called if generate if called when the generator
		 * is allready finished
		 */
		virtual	void		reset() = 0;
};

template <typename T>
Generator<T>::Generator() {}

template <typename T>
Generator<T>::~Generator() {}

#endif
